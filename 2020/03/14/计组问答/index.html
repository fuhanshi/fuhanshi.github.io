<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第一章、计算机系统概述1.计算机发展历程 计算机硬件发展历程：电子管时代–&amp;gt;晶体管时代–&amp;gt;中小规模集成电路时代–&amp;gt;超大规模集成电路时代–&amp;gt;智能计算机–&amp;gt;生物计算机和量子计算机。计算机的分类：专用计算机、通用计算机。摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18~24个月便会增加一倍，性能也将提升一倍。揭示了信息技术进步的速度。其他：操作系统直接影响">
<meta name="keywords" content="Share">
<meta property="og:type" content="article">
<meta property="og:title" content="计组问答">
<meta property="og:url" content="http://yoursite.com/2020/03/14/计组问答/index.html">
<meta property="og:site_name" content="一个大学狗的日常">
<meta property="og:description" content="第一章、计算机系统概述1.计算机发展历程 计算机硬件发展历程：电子管时代–&amp;gt;晶体管时代–&amp;gt;中小规模集成电路时代–&amp;gt;超大规模集成电路时代–&amp;gt;智能计算机–&amp;gt;生物计算机和量子计算机。计算机的分类：专用计算机、通用计算机。摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18~24个月便会增加一倍，性能也将提升一倍。揭示了信息技术进步的速度。其他：操作系统直接影响">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-25T10:21:32.176Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计组问答">
<meta name="twitter:description" content="第一章、计算机系统概述1.计算机发展历程 计算机硬件发展历程：电子管时代–&amp;gt;晶体管时代–&amp;gt;中小规模集成电路时代–&amp;gt;超大规模集成电路时代–&amp;gt;智能计算机–&amp;gt;生物计算机和量子计算机。计算机的分类：专用计算机、通用计算机。摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18~24个月便会增加一倍，性能也将提升一倍。揭示了信息技术进步的速度。其他：操作系统直接影响">



  <link rel="alternate" href="/atom.xml" title="一个大学狗的日常" type="application/atom+xml" />




  <link rel="canonical" href="http://yoursite.com/2020/03/14/计组问答/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>计组问答 | 一个大学狗的日常</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个大学狗的日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃不难，但坚持一定很酷</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />主页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-时间轴">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />时间轴</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/计组问答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="凡希">
      <meta itemprop="description" content="大学狗的日常">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个大学狗的日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计组问答
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-14 16:38:22" itemprop="dateCreated datePublished" datetime="2020-03-14T16:38:22+08:00">2020-03-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-25 18:21:32" itemprop="dateModified" datetime="2020-03-25T18:21:32+08:00">2020-03-25</time>
              
            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第一章、计算机系统概述"><a href="#第一章、计算机系统概述" class="headerlink" title="第一章、计算机系统概述"></a>第一章、计算机系统概述</h2><h3 id="1-计算机发展历程"><a href="#1-计算机发展历程" class="headerlink" title="1.计算机发展历程"></a>1.计算机发展历程</h3><blockquote>
<p><strong>计算机硬件发展历程</strong>：<br><br>电子管时代–&gt;晶体管时代–&gt;中小规模集成电路时代–&gt;超大规模集成电路时代–&gt;智能计算机–&gt;生物计算机和量子计算机。<br><br><strong>计算机的分类</strong>：<br><br>专用计算机、通用计算机。<br><br><strong>摩尔定律</strong>：<br><br>当价格不变时，集成电路上可容纳的元器件的数目，约每隔18~24个月便会增加一倍，性能也将提升一倍。揭示了信息技术进步的速度。<br><br><strong>其他</strong>：操作系统直接影响计算机系统性能。<br></p>
</blockquote>
<h3 id="2-计算机系统层次结构"><a href="#2-计算机系统层次结构" class="headerlink" title="2.计算机系统层次结构"></a>2.计算机系统层次结构</h3><p><code>计算机系统=硬件+软件=（中央处理器、存储器和外部设备等）+（计算机的运行程序和相应的文档）</code><br></p>
<h5 id="2-1-计算机硬件的基本组成"><a href="#2-1-计算机硬件的基本组成" class="headerlink" title="2.1 计算机硬件的基本组成"></a>2.1 计算机硬件的基本组成</h5><blockquote>
<p>(1)<strong>存储器</strong>：分为主存储器（内存储器）和辅助存储器（外存储器）。主存储器存放重程序和数据，辅助存储器中的信息必须调入主存后才能被CPU访问。<br><br>(2)<strong>运算器</strong>：主要功能时进行算术运算和逻辑运算，核心是算数逻辑单元（ALU）。运算器包含若干通用寄存器。<br><br>(3)<strong>控制器</strong>：计算机的指挥中心。由<code>程序计数器（PC）</code>、<code>指令寄存器（IR）</code>和<code>控制单元（CU）</code>组成。<br><br>(4)输入设备。<br><br>(5)输出设备。<br></p>
</blockquote>
<h4 id="2-2-计算机软件的分类"><a href="#2-2-计算机软件的分类" class="headerlink" title="2.2 计算机软件的分类"></a>2.2 计算机软件的分类</h4><blockquote>
<p>（1）系统软件；<br><br>（2）应用软件。<br></p>
</blockquote>
<h4 id="2-3-计算机编程语言分类"><a href="#2-3-计算机编程语言分类" class="headerlink" title="2.3 计算机编程语言分类"></a>2.3 计算机编程语言分类</h4><blockquote>
<p>机器语言、汇编语言、高级语言。<br></p>
</blockquote>
<h4 id="2-4-编译程序与解释程序的区别"><a href="#2-4-编译程序与解释程序的区别" class="headerlink" title="2.4 编译程序与解释程序的区别"></a>2.4 编译程序与解释程序的区别</h4><blockquote>
<p>编译程序生成目标代码，而解释程序不生成；编译程序产生目标代码的执行速度比解释程序的执行速度快。<br></p>
</blockquote>
<h4 id="2-5-计算机的工作过程"><a href="#2-5-计算机的工作过程" class="headerlink" title="2.5 计算机的工作过程"></a>2.5 计算机的工作过程</h4><blockquote>
<p>不断地从存储器中逐条取出指令，然后送至控制器，经分析后由CPU发出各种操作命令，指挥各部件完成各种操作，直至程序中全部指令执行结束。<br></p>
</blockquote>
<h4 id="2-6-计算机系统的层次结构"><a href="#2-6-计算机系统的层次结构" class="headerlink" title="2.6 计算机系统的层次结构"></a>2.6 计算机系统的层次结构</h4><blockquote>
<p>(1)第1级。微程序机器级。微指令由硬件直接执行。<br><br>(2)第2级。传统机器级(机器语言)。用微程序解释指令系统。<br><br>(3)第3级。操作系统级。用机器语言解释作业控制语句；<br><br>(4)第4级。汇编语言机器级。用汇编程序翻译成汇编语言程序；<br><br>(5)第5级。高级语言机器级。用编译程序翻译成汇编程序或直接翻译成机器语言。<br></p>
</blockquote>
<h3 id="3-计算机性能指标"><a href="#3-计算机性能指标" class="headerlink" title="3.计算机性能指标"></a>3.计算机性能指标</h3><blockquote>
<p>(1)<strong>吞吐量</strong>：单位时间内的数据处理量，主要取决于主存的存取周期；<br><br>(2)<strong>响应时间</strong>：从提交作业到该作业得到CPU响应所经理的时间。响应时间越短，吞吐量越大。<br><br>(3)<strong>主频</strong>：机器内部主时钟的频率，衡量机器速度；<br><br>(4)<strong>CPU周期</strong>：又称机器周期，指的是从内存读取一条指令字的最短时间。一个指令周期由若干个CPU周期构成；<br><br>(5)<strong>CPU时钟周期</strong>：主频的倒数，是CPU中最小的时间单位。<br><br>(6)<strong>CPI、MIPS、FLOPS</strong>；<br><br>(7)<strong>CPU执行时间</strong>：CPU对某特定程序的执行时间。<br></p>
</blockquote>
<h2 id="第三章、存储器层次结构"><a href="#第三章、存储器层次结构" class="headerlink" title="第三章、存储器层次结构"></a>第三章、存储器层次结构</h2><h3 id="1-存储器的分类"><a href="#1-存储器的分类" class="headerlink" title="1. 存储器的分类"></a>1. 存储器的分类</h3><p>存储器=主存储器+高速缓冲存储器（Cache）+辅助存储器<br></p>
<blockquote>
<p>(1)按照<strong>存储介质</strong>可分为：<br><br>1)<code>半导体存储器</code>：包括随机存储器和只读存储器两类（RAM和ROM）；<br><br>2)<code>磁表面存储器</code>：包括磁盘、磁带，使用顺序存取方式；<br><br>3)<code>光盘存储器</code>：也叫光存储器，一般指光盘；<br><br>4)<code>磁心存储器</code>：由各种磁心制成，目前已被半导体存储器取代。<br><br>(2)按<strong>存取方式</strong>可分为：<br><br>1)<code>随机存取存储器（RAM）</code>：可存可取，存取时间和存取位置没有关系。<br><br>优点：读写方便，使用灵活；<br><br>缺点：断电信息丢失。<br><br>分为静态RAM（SRAM，常用作高速缓冲存储器）和动态RAM（DRAM常用作主存）<br><br>2)<code>只读存储器（ROM）</code>：只可取，一般把一些固定的、不变的程序存放在这里，其内容断电后仍可保留。<br><br>3)<code>串行访问存储器</code>：在对存储单元进行读写操作时，需要按照物理位置的先后顺序依次访问，主要包括顺序存取存储器（磁带）和直接存取存储器（磁盘，半串行，因为要先寻道）。<br><br>(3)按照<strong>在计算机中的作用</strong>可分为：<br><br>1）主存储器；<br><br>2)辅助存储器；<br><br>3)缓冲存储器。<br></p>
</blockquote>
<h3 id="2-存储器的性能指标"><a href="#2-存储器的性能指标" class="headerlink" title="2.存储器的性能指标"></a>2.存储器的性能指标</h3><blockquote>
<p>(1)存储容量=存储字数(表示存储器的地址空间大小即存储器的存储单元数目)*字长(存储字长，表示一次存取操作的数据量);<br><br>(2)单位成本：每位价格=总成本/总容量；<br><br>(3)存储速度：数据传输率=数据的宽度/存储周期（ 存储周期又称读写周期或访问周期，指连续两次独立地访问存储器操作之间所需的最小时间间隔）。<br></p>
</blockquote>
<h3 id="3-存储周期与存取时间的区别"><a href="#3-存储周期与存取时间的区别" class="headerlink" title="3.存储周期与存取时间的区别"></a>3.存储周期与存取时间的区别</h3><blockquote>
<p>存储周期又称读写周期或访问周期，指连续两次独立地访问存储器操作之间所需的最小时间间隔，而存取时间是指启动一次存储器操作到完成该操作所经历的时间，一般小于存储周期。<br></p>
</blockquote>
<h3 id="4-存储器的层次化结构"><a href="#4-存储器的层次化结构" class="headerlink" title="4.存储器的层次化结构"></a>4.存储器的层次化结构</h3><blockquote>
<p><strong>缓存-主存层次</strong>主要解决CPU和主存速度不匹配的问题。主存和缓存之间的数据交换是由硬件自动完成的，对程序员是透明的；<br><br><strong>主存-辅存层次</strong>主要解决层次系统的容量问题。主存和辅存之间的数据交换是由硬件和操作系统共同完成的。<br></p>
</blockquote>
<h3 id="5-半导体随机存取存储器"><a href="#5-半导体随机存取存储器" class="headerlink" title="5. 半导体随机存取存储器"></a>5. 半导体随机存取存储器</h3><h4 id="5-1-半导体存储芯片的基本结构"><a href="#5-1-半导体存储芯片的基本结构" class="headerlink" title="5.1 半导体存储芯片的基本结构"></a>5.1 半导体存储芯片的基本结构</h4><blockquote>
<p>半导体存储芯片主要由存储矩阵、译码驱动电路和读/写电路组成。<br><br>地址线是单向的，数据线是双向的，其余的属于控制线，包括读/写控制线（用来进行读/写操作）和片选线（用来选择存储芯片）。<br></p>
</blockquote>
<h4 id="5-2-半导体存储芯片的译码驱动方式"><a href="#5-2-半导体存储芯片的译码驱动方式" class="headerlink" title="5.2 半导体存储芯片的译码驱动方式"></a>5.2 半导体存储芯片的译码驱动方式</h4><blockquote>
<p>译码驱动：将地址线送来的地址信号转换成对应存储单元的选择信号。<br><br>(1)<strong>线选法</strong>（单译码）：矩阵有N行，则需要地址线$log_2N$根；矩阵每行有m位(也就是m列)，则需要m根数据线；<br><br>(2)<strong>*重合法</strong>（双译码）：同时需要行和列的地址线。32($2^5$)行里选中1行需要5根地址线，32($2^5$)列选中一列也需要5根地址线，一共需要10根地址线。<br></p>
</blockquote>
<h4 id="5-3-静态RAM（SRAM）存储器"><a href="#5-3-静态RAM（SRAM）存储器" class="headerlink" title="5.3 静态RAM（SRAM）存储器"></a>5.3 静态RAM（SRAM）存储器</h4><blockquote>
<p>存储器的工作：保持存储信息、读数据和写数据<br></p>
</blockquote>
<h4 id="5-4-动态RAM（DRAM）存储器"><a href="#5-4-动态RAM（DRAM）存储器" class="headerlink" title="5.4 动态RAM（DRAM）存储器"></a>5.4 动态RAM（DRAM）存储器</h4><blockquote>
<p>存储器的工作：保持存储信息、读数据和写数据<br><br>DRAM存储器的刷新：采用电容式存储，按行刷新(因为存储体是矩阵形式)，由硬件支持，不由CPU指挥，占一个读/写周期。<br><br>3种<strong>刷新方式</strong>：<br><br>1)集中刷新：把刷新操作集中到一段时间内进行；<br><br>2)分散刷新：将刷新操作分散进行，周期性的进行；<br><br>3)异步刷新：是一个折中方案，有计划的刷新，时间分配十分合理。<br><br>刷新的实质：读出后再按原样写入。<br></p>
</blockquote>
<h4 id="5-5-只读存储器（ROM）"><a href="#5-5-只读存储器（ROM）" class="headerlink" title="5.5 只读存储器（ROM）"></a>5.5 只读存储器（ROM）</h4><blockquote>
<p>可分为：<br><br>掩膜型只读存储器(MROM)、可编程只读存储器(PROM)、可擦除可编程存储器(EPROM)、电可擦除可编程存储器(EEPROM)、快擦除读写存储器(Flash Memory，又叫闪存，集合了ROM和RAM的长处)。<bf></bf></p>
</blockquote>
<h4 id="5-6-对比ROM和RAM"><a href="#5-6-对比ROM和RAM" class="headerlink" title="5.6 对比ROM和RAM"></a>5.6 对比ROM和RAM</h4><blockquote>
<p>存取方式一样，都是随机存取。不同的是，ROM只读，RAM可读可写。<br></p>
</blockquote>
<h4 id="5-7-存储器容量扩充"><a href="#5-7-存储器容量扩充" class="headerlink" title="5.7 存储器容量扩充"></a>5.7 存储器容量扩充</h4><blockquote>
<p><strong>概念</strong>：将若干个存储芯片连接在一起组成足够容量的存储器。<br></p>
<p><strong>补充求芯片数量的公式</strong>：若要求将容量为<code>a*b（a为字线，连接地址线）</code>的芯片组成容量为<code>c*d</code>的芯片，则协议的芯片数量<code>n=(c*d)/a*b（整个存储器的容量除以单个芯片的容量）</code><br></p>
<p>3类<strong>扩充方法</strong>：<br></p>
<p>1)位扩充（增加<code>a*b中的b</code>）：<br><br>增加存储字长，横向扩展，比如要将<code>1K*4</code>位的芯片组成<code>1K*8</code>位的存储器，过程如下：需要<code>（1K*8）/（1K*4）=2</code>片芯片，需要10根地址线（$2^{10}=1K$），需要8根数据线（<code>1K*8</code>中的8代表位数）；<br></p>
<p>2)字扩充（增加<code>a*b中的a</code>）：<br><br>增加存储单元的个数，纵向扩展，比如要将<code>1K*8</code>位的芯片组成<code>2K*8</code>位的存储器，过程如下：需要<code>（2K*8）/（1K*8）=2</code>片芯片，需要11根地址线（$2^{11}=2K$），需要8根数据线（<code>2K*8</code>中的8代表位数）；<br></p>
</blockquote>
<p>3）字位扩充（增加<code>a*b中的a和b</code>）：<br></p>
<blockquote>
<p>增加存储单元的个数和存储字长，纵向扩展，比如要将<code>1K*4</code>位的芯片组成<code>4K*8</code>位的存储器，过程如下：需要<code>（4K*8）/（1K*4）=8</code>片芯片，需要11根地址线（$2^{12}=4K$），需要8根数据线（<code>2K*8</code>中的8代表位数）；<br></p>
</blockquote>
<h3 id="6-双口RAM"><a href="#6-双口RAM" class="headerlink" title="6. 双口RAM"></a>6. 双口RAM</h3><blockquote>
<p>具有两组相互独立的地址线、数据线和读/写控制线。<br><br>可以并行工作，是一种高速工作的存储器；<br><br>有可能在同一时间两个端口同时操作存储器的同一个存储单元，因此设置了<code>BUSY</code>标志。<br></p>
</blockquote>
<h3 id="7-多模块存储器（解决了CPU与I-O设备速度不匹配的问题，提高了存储器的工作速度）"><a href="#7-多模块存储器（解决了CPU与I-O设备速度不匹配的问题，提高了存储器的工作速度）" class="headerlink" title="7. 多模块存储器（解决了CPU与I/O设备速度不匹配的问题，提高了存储器的工作速度）"></a>7. 多模块存储器（解决了CPU与I/O设备速度不匹配的问题，提高了存储器的工作速度）</h3><blockquote>
<p>不同于寻找更高速的元件和采用存储器层次结构，这种方法是通过调整主存的结构来提高访存速度，主要有两类：单体多字存储器、多体并行存储器<br></p>
</blockquote>
<h4 id="7-1-单体多字存储器"><a href="#7-1-单体多字存储器" class="headerlink" title="7.1 单体多字存储器"></a>7.1 单体多字存储器</h4><blockquote>
<p><strong>使用前提</strong>：指令和数据在主存内必须连续存放；<br><br><strong>原理</strong>：把存储器的<code>存储字</code>字长增加n倍，以存放n个指令字或数据字，于是单体多字存储器的最大带宽比单体单字存储器的最大带宽提高n倍。正常情况下不可能达到最大带宽，因为程序使用指令字和数据字存在随机性。；<br><br><strong>缺点</strong>：必须凑齐n个数据字之后才能作为一个存储字一次写入存储器，因此需要首先把属于一个存储字的n个数据字读入到数据寄存器中，等数据寄存器达到了一个存储字的长度，再将其写入存储器。</p>
</blockquote>
<h4 id="7-2-多体并行存储器"><a href="#7-2-多体并行存储器" class="headerlink" title="7.2 多体并行存储器"></a>7.2 多体并行存储器</h4><blockquote>
<p>所谓多体并行存储器，就是采用多个模块组成的存储器，每个模块有着相同的容量和存取速度，各个模块都有独立的地址寄存器、数据寄存器、地址译码器和读/写电路，每个模块都可以看做一个独立的存储器。<br><br>主要分为两种：高位交叉编址的多体并行存储器、低位交叉编址的多体并行存储器<br></p>
</blockquote>
<h5 id="7-2-1-高位交叉编址的多体并行存储器-竖着走，按列扫描"><a href="#7-2-1-高位交叉编址的多体并行存储器-竖着走，按列扫描" class="headerlink" title="7.2.1 高位交叉编址的多体并行存储器(竖着走，按列扫描)"></a>7.2.1 高位交叉编址的多体并行存储器(竖着走，按列扫描)</h5><blockquote>
<p>高位地址表示体号，低位地址定位体内地址。由于每个模块内的体内地址顺序是连续的，因此又称<code>顺序存储</code>。这样，可以在同一时间使得不同的请求源同时访问不同的体，进而实现个体的并行工作。<br><br><strong>特点</strong>：相邻两个字在同一个存储体中，高位的变动才会产生交叉访问的效果。<br><br><strong>优点</strong>：非常有利于存储器的扩充，只需将存储单元的编号往后加即可。<br><br><strong>缺点</strong>：由于各个模块一个接一个的串行工作，因此存储器的带宽受到了限制。<br></p>
</blockquote>
<h5 id="7-2-2-低位交叉编址的多体并行存储器-横着走，按行扫描"><a href="#7-2-2-低位交叉编址的多体并行存储器-横着走，按行扫描" class="headerlink" title="7.2.2 低位交叉编址的多体并行存储器(横着走，按行扫描)"></a>7.2.2 低位交叉编址的多体并行存储器(横着走，按行扫描)</h5><blockquote>
<p>由于程序是存放在相邻的体中，因此又称<code>交叉存储</code>。低位为体号，高位定位体内地址。<br><br><strong>特点</strong>：连续地址分布在相邻的不同模块内，而同一个模块内的地址都是不连续的。<br></p>
</blockquote>
<h3 id="8-高速缓冲存储器（Cache）–提高存储系统的工作速度"><a href="#8-高速缓冲存储器（Cache）–提高存储系统的工作速度" class="headerlink" title="8. 高速缓冲存储器（Cache）–提高存储系统的工作速度"></a>8. 高速缓冲存储器（Cache）–提高存储系统的工作速度</h3><h4 id="8-1-主存和Cache的编址"><a href="#8-1-主存和Cache的编址" class="headerlink" title="8.1 主存和Cache的编址"></a>8.1 主存和Cache的编址</h4><blockquote>
<p>主存由一个个的字块组成，主存的地址分为两部分：高m位表示主存的块地址，低b位表示其块内的字或字节。同理，Cache的地址也应分为两部分：高ｃ位表示Cache的块号，低ｂ位表示其块内的字或字节数。<br><br><strong>命中率</strong>：CPU要访问的的信息在Cache中的比例；<br><br><strong>平均访问时间</strong>：假设命中率为$h$，$t_c$为命中时访问Cache的时间，$t_m$为未命中时的主存访问时间，则Cache-主存系统的平均访问时间$t_a$为$t_a=ht_c+(1-h)t_m$；<br><br><strong>Cache-主存系统效率</strong>：$e=t_c/t_a$ 。<br></p>
</blockquote>
<ul>
<li>Cache的命中率只与<code>Cache的容量</code>、<code>Cache的字块长度</code>有关。<br></li>
<li>主存与Cache之间传送数据的基本单位是块，而主存与CPU之间传送数据的基本单位是字（一个块包含多个字）。<br></li>
</ul>
<h4 id="8-2-Cache的基本结构"><a href="#8-2-Cache的基本结构" class="headerlink" title="8.2 Cache的基本结构"></a>8.2 Cache的基本结构</h4><blockquote>
<p>地址映射变换机构(将CPU送来的主存地址转换成Cache地址)；<br><br>替换机构。<br></p>
</blockquote>
<h4 id="8-3-指令和数据是放在同一个Cache中吗？"><a href="#8-3-指令和数据是放在同一个Cache中吗？" class="headerlink" title="8.3 指令和数据是放在同一个Cache中吗？"></a>8.3 指令和数据是放在同一个Cache中吗？</h4><blockquote>
<p>一级Cache的指令和数据一般分开存放，而二级Cache的指令和数据放在一起，因此有<code>L1 data Cache</code>和<code>L1 code Cache</code>。<br></p>
</blockquote>
<h4 id="8-4-一些其他知识点youdian"><a href="#8-4-一些其他知识点youdian" class="headerlink" title="8.4 一些其他知识点youdian"></a>8.4 一些其他知识点youdian</h4><blockquote>
<p>在CPU和主存之间增加Cache并不能增加计算机总存储量；<br><br>程序员无需知道高速缓存的访问过程。<br></p>
</blockquote>
<h3 id="9-Cache和主存之间的映射方式-主存块号–-gt-CPU块号"><a href="#9-Cache和主存之间的映射方式-主存块号–-gt-CPU块号" class="headerlink" title="9. Cache和主存之间的映射方式(主存块号–&gt;CPU块号)"></a>9. Cache和主存之间的映射方式(主存块号–&gt;CPU块号)</h3><blockquote>
<p>(1)<strong>直接映射</strong>：每个缓存块可以和若干个主存块对应，每个主存块只能和一个缓存块对应。<br><br>优点：实现简单。<br><br>缺点：不够灵活(容易造成空闲Cache块的浪费)、冲突概率高(抖动)。<br><br>应用场合：适合大容量Cache。<br><br>(2)<strong>全相联映射</strong>：主存中每一个字块可以映射到Cache中的任何一块。<br><br>优点：Cache的命中率提高了、减小了块的冲突率(空位随便坐)进而提高了Cache的利用率。<br><br>缺点：tag的位数增加了，访问Cache时主存字块标记需要和Cache的全部“标记”进行比较，才能判断所访问主存地址是否已在Cache内。<br><br>应用场合：适用于小容量的Cache。<br><br>(3)<strong>组相联映射</strong>：按号分组，组内随意放(把Cache分成Q组，每组有R块)，这样，组间是直接映射，组内是全相联映射，虽没有直接相连的速度快，但电路实现简单(只需进行组间本比较，而无需<code>对Cache的每一块进行比较[全相联是这样子的，它需要]</code>)，命中率高。</p>
</blockquote>
<h3 id="10-Cache中主存块的替换算法（针对全相联和组相联，至于直接映射只需直接替换就好了）"><a href="#10-Cache中主存块的替换算法（针对全相联和组相联，至于直接映射只需直接替换就好了）" class="headerlink" title="10.Cache中主存块的替换算法（针对全相联和组相联，至于直接映射只需直接替换就好了）"></a>10.Cache中主存块的替换算法（针对全相联和组相联，至于直接映射只需直接替换就好了）</h3><blockquote>
<p>先进先出，近期最少使用(理想，预测性，难以实现)，最不经常使用，随机法。<br></p>
</blockquote>
<h3 id="11-Cache写操作策略（同步Cache块与主存块中的内容）"><a href="#11-Cache写操作策略（同步Cache块与主存块中的内容）" class="headerlink" title="11. Cache写操作策略（同步Cache块与主存块中的内容）"></a>11. Cache写操作策略（同步Cache块与主存块中的内容）</h3><blockquote>
<p>(1)<strong>写回法</strong>：<br><br>当CPU写Cache命中时，只修改Cache的内容，而不立即写入主存，只有当此行被换出时才写回主存。这样减少了访存次数。Cache的每一行都设置一个修改位(脏位)，当某行被换出时，根据此行的修改位来决定将该行内容写回主存还是简单丢弃。<br></p>
</blockquote>
<p>若未命中，则使用<code>写分配法</code>：加载主存中的块到Cache中，然后在Cache中更新，最后同步到主存。<br></p>
<blockquote>
<p>(2)<strong>全写法</strong>：<br><br>当写Cache命中时，Cache与主存同时发生写修改。<br></p>
</blockquote>
<p>若未命中，则使用<code>非写分配法</code>：只写入主存而不调入Cache。<br></p>
<blockquote>
<p>(3)<strong>写一次法</strong>：<br><br>以上两种方法的折中，写命中与写未命中的处理方法与写回法基本一致，仅仅是第一次写命中时要同时写入主存。<br></p>
</blockquote>
<h3 id="12-虚拟存储器"><a href="#12-虚拟存储器" class="headerlink" title="12. 虚拟存储器"></a>12. 虚拟存储器</h3><p>详见操作系统。<br></p>
<h2 id="第四章、指令系统"><a href="#第四章、指令系统" class="headerlink" title="第四章、指令系统"></a>第四章、指令系统</h2><h3 id="1-指令概述"><a href="#1-指令概述" class="headerlink" title="1. 指令概述"></a>1. 指令概述</h3><blockquote>
<p>构成机器语言的一条条语句就是一条条<strong>机器指令</strong>，全部机器指令的集合就是<strong>机器的指令系统</strong>。<br><br>一条指令包括<code>操作码</code>和<code>地址码</code>两部分：<br><br><strong>操作码</strong>：分为<code>定长操作码</code>和<code>不定长操作码</code>。告诉要做什么操作（比如，加减乘除）；<br><br><strong>地址码</strong>：又称<code>操作数字段</code>，其任务是：指出操作数的地址、运算结果需存放的地址、下一条指令的地址。<br></p>
</blockquote>
<h3 id="2-指令分类"><a href="#2-指令分类" class="headerlink" title="2. 指令分类"></a>2. 指令分类</h3><blockquote>
<p>(1)<strong>零地址指令</strong>：只给出操作码字段OP，适用于：1）不需要操作数的指令，比如停机指令、关中断指令等；2）堆栈计算机中的零地址运算类指令。<br><br>(2)<strong>一地址指令</strong>：地址码字段只有一个，适用于：1）单目运算，如求反，减一等；2）隐含约定目的地址的双操作数指令。假设指令字长32位，地址码字段24位，则寻址范围是$2^{24}=16M$ <br><br>(3)<strong>二地址指令</strong>：有两个地址码字段，一个是源操作数地址，另一个是目的操作数地址，适用于各类加减乘除运算。假设指令字长32位，操作码8位，两个地址码字段各12位，则寻址范围是$2^{12}=4K$。<br><br>(4)<strong>三地址指令</strong>：有三个地址码字段。假设指令字长32位，操作码8位，三个地址码字段各8位，则寻址范围是$2^8=256$ <br><br>(5)<strong>四地址指令</strong>：有四个地址码字段。若指令字长32位，操作码8位，4个地址码各6位，则直接寻址范围是$2^6==64$。<br></p>
</blockquote>
<p>指令字长取决于操作码的长度、操作数地址的长度、操作数地址的个数。<br><br>每一条指令指令都必须告诉CPU该指令如何做，因此必须指定操作码。<br></p>
<h3 id="3-什么是指令字长"><a href="#3-什么是指令字长" class="headerlink" title="3.什么是指令字长"></a>3.什么是指令字长</h3><blockquote>
<p>指令字长是指一条指令所占用存储空间的大小。指令字长一般为字节的整数倍。<br><br>单字长指令：指令长度=机器字长；<br><br>半字长指令：指令长度=0.5<em>机器字长；<br><br>双字长指令：指令长度=2</em>机器字长。<br></p>
</blockquote>
<h3 id="4-区分数据字和指令字"><a href="#4-区分数据字和指令字" class="headerlink" title="4.区分数据字和指令字"></a>4.区分数据字和指令字</h3><blockquote>
<p>如果计算机中的某一个字表示的是一个数据，则此字称为<code>数据字</code>；<br><br>如果计算机中的某一个字表示的是一条指令，则此字就称为<code>指令字</code>。<br></p>
</blockquote>
<h3 id="5-定长操作码和不定长操作码"><a href="#5-定长操作码和不定长操作码" class="headerlink" title="5. 定长操作码和不定长操作码"></a>5. 定长操作码和不定长操作码</h3><blockquote>
<p><strong>定长操作码</strong>：在指令字的最高位部分分配固定的若干位表示操作码。对于具有n位操作码字段的指令系统，最多能够表示$2^n$条指令。<br><br><strong>不定长操作码</strong>：操作码的长度随地址码个数的减少而增加，不同的地址数的指令可以具有不同长度的操作码。这样子可以在满足需要的前提下有效的缩指令字长。需要注意的是：不允许较短的操作码是较长的操作码的前缀；各条指令的操作码一定不可以重复。<br></p>
</blockquote>
<h3 id="6-指令的寻址方式"><a href="#6-指令的寻址方式" class="headerlink" title="6.指令的寻址方式"></a>6.指令的寻址方式</h3><blockquote>
<p>定义：是指指令或操作数有效地址的寻找方式，主要分为<code>数据寻址</code>和<code>指令寻址</code>。<br><br>寻址的原因：因为指令的地址码字段往往并不是操作数的真实地址，而是形式地址。<br></p>
</blockquote>
<h4 id="6-1-指令寻址和数据寻址的比较"><a href="#6-1-指令寻址和数据寻址的比较" class="headerlink" title="6.1 指令寻址和数据寻址的比较"></a>6.1 指令寻址和数据寻址的比较</h4><blockquote>
<p>确定指令存放位置的过程称为<code>指令寻址方式</code>，确定操作数存放位置的过程称为<code>数据寻址方式</code>，两者复杂度不一样。<br><br><strong>指令寻址</strong>是指找到下一条将要执行的指令的地址，有两种方式：顺序执行(用指令计数器(PC)+1来得到下一条在指令的地址)和跳转执行(通过转移指令的寻址方式，计算出目标地址，送到PC中即可。目标转移地址的形成方式主要有3种：立即寻址(直接地址)、相对寻址(相对地址)、间接寻址(间接地址))。<br><br><strong>数据寻址</strong>是指找到当前正在执行指令的数据地址。为了区分各种数据寻址方式，通常在指令字中设置一个字段，用来致命使用何种寻址方式，这样，数据指令字的结构变为{操作码，寻址特征，形式地址(A)}。<br></p>
</blockquote>
<h4 id="6-2常见的数据寻址方式"><a href="#6-2常见的数据寻址方式" class="headerlink" title="6.2常见的数据寻址方式"></a>6.2常见的数据寻址方式</h4><blockquote>
<p>(1)<strong>立即寻址</strong>：立即给出操作数，不需要给出地址去其他地方找操作数。只需要在取指令时访问存储器，而在执行阶段不需要。但A的位数限制了立即寻址的范围。常用于对某寄存器或内存单元赋初值。<br></p>
<p>(2)<strong>直接寻址</strong>：通过指令中的地址码字段找到真实地址(取货码取快递)，执行阶段需要访问一次存储器去取操作数。直接给出了操作数的有效地址，寻找操作数简单，但是寻址范围较小(操作数的有效地址仅由A决定，而A的位数一般都比较小，因此寻址范围比较小)。<br></p>
</blockquote>
<blockquote>
<p>(3)<strong>隐含寻址</strong>：指令字不明显的给出操作数的地址，其操作数地址隐含在操作码或者某个寄存器中。有利于缩短指令字长，但是需要增加存储操作数或隐含地址的硬件。<br></p>
</blockquote>
<blockquote>
<p>(4)<strong>间接寻址</strong>：解决了直接寻址的寻址范围小的问题。直接寻址直接给出了操作数的有效地址，而间接寻址给出的是<code>操作数有效地址的地址</code>。间接寻址又可以分为<code>一次间接寻址</code>和<code>多次间接寻址</code>。便于子程序返回和查表，但N次间接寻址需要在指令阶段还需要访问存储器<code>N+1</code>次(前N次找操作数的有效地址，最后一次找操作数)。<br></p>
</blockquote>
<blockquote>
<p>(5)<strong>寄存器寻址</strong>：和直接寻址类似，在直接寻址的指令字中，地址码字段给出的是主存地址，而在寄存器寻址的指令字中，地址码字段直接给出的是寄存器编号$R_i$，则操作数的有效地址为$EA=R_i$。</p>
</blockquote>
<blockquote>
<p>(6)<strong>寄存器间接寻址</strong>：和寄存器寻址不同之处在于，$R_i$中存放的不是操作数，而是操作数所在主存单元的地址号，有效地址$EA=(R_i)$。便于编制循环程序，但需要访问一次存储器去取操作数。<br></p>
</blockquote>
<blockquote>
<p>(7)<strong>基址寻址</strong>：设置一个基址寄存器(BR)，则其操作数的有效地址等于指令字中的形式地址A与基址寄存器中的内容(基地址)相加，即：$EA=A+(BR)$。扩大了操作数的寻址范围(因为基址寄存器的位数可以大于形式地址Ade位数)，便于解决多道程序问题。注意：基址寄存器的内容由操作系统确定，但用户有权知道使用了哪个寄存器作为基址寄存器。<br></p>
</blockquote>
<blockquote>
<p>(8)<strong>变址寻址</strong>：不同于基址寻址，在变址寻址中，变址寄存器中的内容由用户设定，在程序执行过程中其值可变，而指令字中的形式地址A是不可变的。也扩大了操作数的寻址范围，非常适合处理数组和循环问题。<br></p>
</blockquote>
<blockquote>
<p>(9)<strong>相对寻址</strong>：基于程序局部性原理，相对寻址的有效地址是将程序计数器(PC)的内容与指令字中的形式地址A相加而成，即：$EA=(PC)+A$。用于转移类指令，便与编制浮动程序。<br></p>
</blockquote>
<h3 id="7-CIRC和RISC的基本概念"><a href="#7-CIRC和RISC的基本概念" class="headerlink" title="7. CIRC和RISC的基本概念"></a>7. CIRC和RISC的基本概念</h3><h4 id="7-1-CISC的主要特点"><a href="#7-1-CISC的主要特点" class="headerlink" title="7.1 CISC的主要特点"></a>7.1 CISC的主要特点</h4><blockquote>
<p>(1) 指令系统复杂庞大；<br><br>(2)指令长度不固定，指令格式种类多，寻址方式种类多；<br><br>(3)可以访存的指令不受限制(RISC只有取数/存数指令访问存储器)；<br><br>(4)由于80%的程序只是用20%的指令，因此CISC各指令的使用频率差距太大；<br><br>(5)各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成；<br><br>(6)控制器大多数采用微程序控制；<br><br>(7)难以用优化编译生成高效的目标代码程序。<br></p>
</blockquote>
<h4 id="7-2-80-20定律"><a href="#7-2-80-20定律" class="headerlink" title="7.2 80-20定律"></a>7.2 80-20定律</h4><blockquote>
<p>典型程序中80%的语句都是使用计算机中20%的指令，而这20%的指令都属于简单指令。<br></p>
</blockquote>
<p>于是<code>RISC</code>出现了！<br></p>
<h4 id="7-3-RISC的主要特点"><a href="#7-3-RISC的主要特点" class="headerlink" title="7.3 RISC的主要特点"></a>7.3 RISC的主要特点</h4><blockquote>
<p>(1)把复杂指令的功能用使用频率较高的简单指令实现；<br><br>(2)指令长度固定，指令格式种类少，寻址方式种类少；<br><br>(3)只有取数/存数指令访问存储器，其余的指令操作在寄存器中完成；<br><br>(4)CPU中有多个通用寄存器(比CISC的多)；<br><br>(5)一定采用流水线技术，大部分指令在一个时钟周期内完成；<br><br>(6)控制器采用组合逻辑控制，不用微程序控制；<br><br>(7)采用优化的编译程序。<br></p>
</blockquote>
<h4 id="7-4-对比RISC和CISC"><a href="#7-4-对比RISC和CISC" class="headerlink" title="7.4 对比RISC和CISC"></a>7.4 对比RISC和CISC</h4><blockquote>
<p>RISC更能提高计算机的运算速度，更便于设计，可降低成本，提高可靠性，更有效支持高级语言程序。而CISC有专用指令来完成特定的更能，因此处理特殊任务比较高效。<br></p>
</blockquote>

      
    </div>

    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="凡希 wechat" style="width: 200px; max-width: 100%;"/>
    <div>喜欢所以热爱，坚持干货分享，欢迎订阅我的微信公众号</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>呐，请我吃辣条</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="凡希 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="凡希 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/11/各种各样的杨辉三角题目集合/" rel="next" title="各种各样的杨辉三角题目集合">
                <i class="fa fa-chevron-left"></i> 各种各样的杨辉三角题目集合
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/15/R语言原生数据结构总结/" rel="prev" title="R语言原生数据结构总结">
                R语言原生数据结构总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">凡希</p>
              <p class="site-description motion-element" itemprop="description">大学狗的日常</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">97</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章、计算机系统概述"><span class="nav-number">1.</span> <span class="nav-text">第一章、计算机系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-计算机发展历程"><span class="nav-number">1.1.</span> <span class="nav-text">1.计算机发展历程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-计算机系统层次结构"><span class="nav-number">1.2.</span> <span class="nav-text">2.计算机系统层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-计算机硬件的基本组成"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">2.1 计算机硬件的基本组成</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-计算机软件的分类"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.2 计算机软件的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-计算机编程语言分类"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.3 计算机编程语言分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-编译程序与解释程序的区别"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.4 编译程序与解释程序的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-计算机的工作过程"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.5 计算机的工作过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-计算机系统的层次结构"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.6 计算机系统的层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-计算机性能指标"><span class="nav-number">1.3.</span> <span class="nav-text">3.计算机性能指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章、存储器层次结构"><span class="nav-number">2.</span> <span class="nav-text">第三章、存储器层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-存储器的分类"><span class="nav-number">2.1.</span> <span class="nav-text">1. 存储器的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-存储器的性能指标"><span class="nav-number">2.2.</span> <span class="nav-text">2.存储器的性能指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-存储周期与存取时间的区别"><span class="nav-number">2.3.</span> <span class="nav-text">3.存储周期与存取时间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-存储器的层次化结构"><span class="nav-number">2.4.</span> <span class="nav-text">4.存储器的层次化结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-半导体随机存取存储器"><span class="nav-number">2.5.</span> <span class="nav-text">5. 半导体随机存取存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-半导体存储芯片的基本结构"><span class="nav-number">2.5.1.</span> <span class="nav-text">5.1 半导体存储芯片的基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-半导体存储芯片的译码驱动方式"><span class="nav-number">2.5.2.</span> <span class="nav-text">5.2 半导体存储芯片的译码驱动方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-静态RAM（SRAM）存储器"><span class="nav-number">2.5.3.</span> <span class="nav-text">5.3 静态RAM（SRAM）存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-动态RAM（DRAM）存储器"><span class="nav-number">2.5.4.</span> <span class="nav-text">5.4 动态RAM（DRAM）存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-只读存储器（ROM）"><span class="nav-number">2.5.5.</span> <span class="nav-text">5.5 只读存储器（ROM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-对比ROM和RAM"><span class="nav-number">2.5.6.</span> <span class="nav-text">5.6 对比ROM和RAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-7-存储器容量扩充"><span class="nav-number">2.5.7.</span> <span class="nav-text">5.7 存储器容量扩充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-双口RAM"><span class="nav-number">2.6.</span> <span class="nav-text">6. 双口RAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-多模块存储器（解决了CPU与I-O设备速度不匹配的问题，提高了存储器的工作速度）"><span class="nav-number">2.7.</span> <span class="nav-text">7. 多模块存储器（解决了CPU与I/O设备速度不匹配的问题，提高了存储器的工作速度）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-单体多字存储器"><span class="nav-number">2.7.1.</span> <span class="nav-text">7.1 单体多字存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-多体并行存储器"><span class="nav-number">2.7.2.</span> <span class="nav-text">7.2 多体并行存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-1-高位交叉编址的多体并行存储器-竖着走，按列扫描"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">7.2.1 高位交叉编址的多体并行存储器(竖着走，按列扫描)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-2-低位交叉编址的多体并行存储器-横着走，按行扫描"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">7.2.2 低位交叉编址的多体并行存储器(横着走，按行扫描)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-高速缓冲存储器（Cache）–提高存储系统的工作速度"><span class="nav-number">2.8.</span> <span class="nav-text">8. 高速缓冲存储器（Cache）–提高存储系统的工作速度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-主存和Cache的编址"><span class="nav-number">2.8.1.</span> <span class="nav-text">8.1 主存和Cache的编址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-Cache的基本结构"><span class="nav-number">2.8.2.</span> <span class="nav-text">8.2 Cache的基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-指令和数据是放在同一个Cache中吗？"><span class="nav-number">2.8.3.</span> <span class="nav-text">8.3 指令和数据是放在同一个Cache中吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-一些其他知识点youdian"><span class="nav-number">2.8.4.</span> <span class="nav-text">8.4 一些其他知识点youdian</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Cache和主存之间的映射方式-主存块号–-gt-CPU块号"><span class="nav-number">2.9.</span> <span class="nav-text">9. Cache和主存之间的映射方式(主存块号–&gt;CPU块号)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Cache中主存块的替换算法（针对全相联和组相联，至于直接映射只需直接替换就好了）"><span class="nav-number">2.10.</span> <span class="nav-text">10.Cache中主存块的替换算法（针对全相联和组相联，至于直接映射只需直接替换就好了）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Cache写操作策略（同步Cache块与主存块中的内容）"><span class="nav-number">2.11.</span> <span class="nav-text">11. Cache写操作策略（同步Cache块与主存块中的内容）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-虚拟存储器"><span class="nav-number">2.12.</span> <span class="nav-text">12. 虚拟存储器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章、指令系统"><span class="nav-number">3.</span> <span class="nav-text">第四章、指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-指令概述"><span class="nav-number">3.1.</span> <span class="nav-text">1. 指令概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-指令分类"><span class="nav-number">3.2.</span> <span class="nav-text">2. 指令分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-什么是指令字长"><span class="nav-number">3.3.</span> <span class="nav-text">3.什么是指令字长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-区分数据字和指令字"><span class="nav-number">3.4.</span> <span class="nav-text">4.区分数据字和指令字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-定长操作码和不定长操作码"><span class="nav-number">3.5.</span> <span class="nav-text">5. 定长操作码和不定长操作码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-指令的寻址方式"><span class="nav-number">3.6.</span> <span class="nav-text">6.指令的寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-指令寻址和数据寻址的比较"><span class="nav-number">3.6.1.</span> <span class="nav-text">6.1 指令寻址和数据寻址的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2常见的数据寻址方式"><span class="nav-number">3.6.2.</span> <span class="nav-text">6.2常见的数据寻址方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-CIRC和RISC的基本概念"><span class="nav-number">3.7.</span> <span class="nav-text">7. CIRC和RISC的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-CISC的主要特点"><span class="nav-number">3.7.1.</span> <span class="nav-text">7.1 CISC的主要特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-80-20定律"><span class="nav-number">3.7.2.</span> <span class="nav-text">7.2 80-20定律</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-RISC的主要特点"><span class="nav-number">3.7.3.</span> <span class="nav-text">7.3 RISC的主要特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-对比RISC和CISC"><span class="nav-number">3.7.4.</span> <span class="nav-text">7.4 对比RISC和CISC</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">凡希</span>

  

  
</div>










  <div class="footer-custom">微信公众号：我将在南极找寻你</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  

  


  
  

  

  

  

  

  



<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script
</body>
</html>



